#silent $setDefaultRanks(range(0,5))
#silent $addType('logical', 'LOGICAL')
#silent $addType('bool', 'LOGICAL(KIND=C_BOOL)')
#silent $addType('int', 'INTEGER')
#silent $addType('long', 'INTEGER(KIND=C_LONG)')
#silent $addType('float', 'REAL(KIND=C_FLOAT)')
#silent $addType('double', 'REAL(KIND=C_DOUBLE)')
#set $metainfoGetterTypes = [('b', 'LOGICAL'), ('i', 'INTEGER(KIND=C_INT)'),  ('l', 'INTEGER(KIND=C_LONG)'), ('f', 'REAL(KIND=C_FLOAT)'), ('d', 'REAL(KIND=C_DOUBLE)')]  
#set $metainfoSetterTypes = $metainfoGetterTypes + [('s', 'CHARACTER(LEN=*)')]   
!------------------------------------------------------------*- Fortran -*-----
!
!                              S E R I A L B O X
!
! This file is distributed under terms of BSD license.
! See LICENSE.txt for more information.
!
!------------------------------------------------------------------------------
!
!+ This module contains the FortranTestGenerator (FTG) frontend of Serialbox2.
!+ For FTG see https://github.com/fortesg/fortrantestgenerator
!
!------------------------------------------------------------------------------

MODULE m_ser_ftg_cmp

!------------------------------------------------------------------------------
!
! Description:
!
!   This module contains subroutines to compare a given field with stored values. 
!   To be used by the FortranTestGenerator (https://github.com/fortesg/fortrantestgenerator)
!
! Current Code Owner: Christian Hovy, Universitaet Hamburg
!  email:  hovy@informatik.uni-hamburg.de
!
! Code Description:
! Language: Fortran 90.
! Software Standards: "European Standards for Writing and
! Documenting Exchangeable Fortran 90 Code".
!============================================================================

USE iso_c_binding
USE m_ser_ftg

IMPLICIT NONE

PUBLIC :: ftg_cmp_default_tolerance, ftg_cmp_max_print_deviations, ftg_cmp_message_prefix, ftg_compare

PRIVATE

CHARACTER(LEN=*), PARAMETER :: module_name = 'm_ser_ftg_cmp'

INTERFACE ftg_cmp_print_deviations
  MODULE PROCEDURE &
  #for $td in $typesWithDimensions(excludeRanks = [0])
    ftg_cmp_print_deviations_${td.name}_${td.rank}d${td.unlessIsLast(', &')}
  #end for   
END INTERFACE ftg_cmp_print_deviations

INTERFACE ftg_compare
  MODULE PROCEDURE &
  #for $td in $typesWithDimensions  
    ftg_compare_${td.name}_${td.rank}d${td.unlessIsLast(', &')}
  #end for   
END INTERFACE ftg_compare

REAL :: ftg_cmp_default_tolerance = 0.0
INTEGER :: ftg_cmp_max_print_deviations = 10
CHARACTER(len=64) :: ftg_cmp_message_prefix = 'FTG Compare ***'

CONTAINS

!=============================================================================
!=============================================================================

FUNCTION ftg_cmp_size(fieldname, actual_shape, fieldname_print)

  CHARACTER(LEN=*), INTENT(IN) :: fieldname, fieldname_print
  INTEGER, INTENT(IN) :: actual_shape(:)
  INTEGER :: rank, expected_shape(4), i
  LOGICAL :: ftg_cmp_size
  
  rank = SIZE(actual_shape)
  expected_shape = ftg_get_size(fieldname)
  ftg_cmp_size =  ALL(actual_shape == expected_shape(:rank))
  IF (.NOT. ftg_cmp_size) THEN
    WRITE (*,'(A,A,A,A)',advance="no") TRIM(ftg_cmp_message_prefix), " ", TRIM(fieldname_print), " : Size doesn't match, expected: ("
    DO i = 1, rank
      IF (i > 1) THEN
        WRITE(*,'(A)',advance="no") ', '
      END IF
      WRITE (*,'(I0)',advance="no") expected_shape(i)
    END DO
    WRITE (*,'(A)',advance="no") "), actual: ("
    DO i = 1, rank
      IF (i > 1) THEN
        WRITE(*,'(A)',advance="no") ', '
      END IF
      WRITE (*,'(I0)',advance="no") actual_shape(i)
    END DO
    WRITE (*,'(A)') ")"
  END IF

END FUNCTION ftg_cmp_size

!=============================================================================
!=============================================================================
#for $td in $typesWithDimensions(excludeTypes = ['int', 'long', 'float', 'double'], excludeRanks = [0])
  #if $td.name == 'logical' or $td.name == 'bool'
    #set $cmpOprt = '.NEQV.'
  #else
    #set $cmpOprt = '/='
  #end if
  #set $indices = ', '.join(['indices(' + str(r) + ')' for r in range(1, $td.rank + 1)])
  #set $indicesFmt = ','.join(['IO' for r in range(1, $td.rank + 1)])
  #set $contentFmt = {'logical':'L0', 'bool':'L0'}[$td.name]
SUBROUTINE ftg_cmp_print_deviations_${td.name}_${td.rank}d(expected, actual, fieldname_print)
  ${td.datatype}, INTENT(IN) :: expected${td.dimensions}, actual${td.dimensions}
  CHARACTER(LEN=*), INTENT(IN) :: fieldname_print
  LOGICAL, ALLOCATABLE :: mask${td.dimensions}
  INTEGER :: indices(${td.rank}), i, j
  
  mask = expected $cmpOprt actual
  
END SUBROUTINE ftg_cmp_print_deviations_${td.name}_${td.rank}d

#end for
#for $td in $typesWithDimensions(excludeTypes = ['logical', 'bool'], excludeRanks = [0])
  #set $indices = ', '.join(['indices(' + str(r) + ')' for r in range(1, $td.rank + 1)])
  #set $indicesFmt = ','.join(['IO' for r in range(1, $td.rank + 1)])
  #set $contentFmt = {'int':'I0', 'long':'I19', 'float':'F0.14', 'double':'F0.14'}[$td.name]
SUBROUTINE ftg_cmp_print_deviations_${td.name}_${td.rank}d(expected, actual, fieldname_print)
  ${td.datatype}, INTENT(IN) :: expected${td.dimensions}, actual${td.dimensions}
  CHARACTER(LEN=*), INTENT(IN) :: fieldname_print
  LOGICAL, ALLOCATABLE :: mask${td.dimensions}
  ${td.datatype}, ALLOCATABLE :: deltas${td.dimensions}
  INTEGER :: indices(${td.rank}), i, j
  
  mask = expected /= actual
  deltas = expected - actual
  DO i = 1, ftg_cmp_max_print_deviations
    IF (ANY(mask)) THEN
      indices = MAXLOC(deltas, mask)
      WRITE (*,'(A)',advance="no") "  -> ("
      #for r in range(1, $td.rank + 1)
      #if r > 1
      WRITE (*,'(A)',advance="no") ", "
      #end if
      WRITE (*,'(I0)',advance="no") indices($r)
      #end for
      WRITE (*,'(A)',advance="no") "), expected: "
      WRITE (*,'($contentFmt)',advance="no") expected($indices)
      WRITE (*,'(A)',advance="no") ", actual: "
      WRITE (*,'($contentFmt)') actual($indices)
      mask($indices) = .FALSE.
    ELSE
      EXIT
    END IF    
  END DO
  
END SUBROUTINE ftg_cmp_print_deviations_${td.name}_${td.rank}d

#end for
!=============================================================================
!=============================================================================

#for $td in $typesWithDimensions
  #if $td.name == 'float' or $td.name == 'double'
    #set $cmp = 'ABS(field - stored_field) > t'
    #set $tol = ', tolerance'
  #elif $td.name == 'logical' or $td.name == 'bool'
    #set $cmp = 'field .NEQV. stored_field'
    #set $tol = ''
  #else
    #set $cmp = 'field /= stored_field'
    #set $tol = ''
  #end if
SUBROUTINE ftg_compare_${td.name}_${td.rank}d(fieldname, field, result, result_acc$tol, fieldname_alias)
  CHARACTER(LEN=*), INTENT(IN) :: fieldname
  ${td.datatype}, INTENT(IN) :: field${td.dimensions}
  LOGICAL, INTENT(OUT) :: result
  LOGICAL, INTENT(INOUT), OPTIONAL :: result_acc
  CHARACTER(LEN=*), INTENT(IN), OPTIONAL :: fieldname_alias
  CHARACTER(LEN=256) :: fieldname_print
  ${td.datatype}, ALLOCATABLE :: stored_field${td.dimensions}
  #if $td.name == 'float' or $td.name == 'double'
  ${td.datatype}, INTENT(in), OPTIONAL :: tolerance
  ${td.datatype} :: t
  
  IF (PRESENT(tolerance)) THEN
    t = tolerance
  ELSE
    t = ftg_cmp_default_tolerance
  END IF
  #end if
  
  IF (PRESENT(fieldname_alias)) THEN
    fieldname_print = fieldname_alias
  ELSE
    fieldname_print = fieldname
  END IF
  
  result = .TRUE.

  #if $td.rank == 0
  CALL ftg_allocate_and_read_allocatable(fieldname, stored_field)
  IF ($cmp) THEN
    result = .FALSE.
  END IF
  #else 
  IF (.NOT. ftg_cmp_size(fieldname, SHAPE(field), fieldname_print)) THEN
    result = .FALSE.
  ELSE
    CALL ftg_allocate_and_read_allocatable(fieldname, stored_field)
    IF (ANY($cmp)) THEN
      result = .FALSE.
      IF (ftg_cmp_max_print_deviations > 0) THEN
        WRITE (*,'(A,A,A,A)') TRIM(ftg_cmp_message_prefix), " ", TRIM(fieldname_print), " : Not equal"
        CALL ftg_cmp_print_deviations(stored_field, field, fieldname_print)
      END IF 
    END IF
  END IF
  #end if
  
  IF (PRESENT(result_acc)) THEN
    result_acc = result_acc .AND. result
  END IF
    
END SUBROUTINE ftg_compare_${td.name}_${td.rank}d

#end for
END MODULE m_ser_ftg_cmp
